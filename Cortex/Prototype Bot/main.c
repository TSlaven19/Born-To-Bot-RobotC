#pragma config(Motor,	 port1,						ARM_R,				 tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,	 port2,						R_DRIVE,			 tmotorVex393_MC29, openLoop)
#pragma config(Motor,	 port4,						FLIP,					 tmotorVex393_MC29, openLoop)
#pragma config(Motor,	 port5,						FLY_W_A,			 tmotorVex393_MC29, openLoop)
#pragma config(Motor,	 port6,						FLY_W_B,			 tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,	 port7,						INTAKE,				 tmotorVex393_MC29, openLoop)
#pragma config(Motor,	 port8,						L_DRIVE,			 tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,	 port10,					ARM_L,				 tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

int fs = 127; //fullspeed
int ds = 1; //drivespeed

//Drive input calc
float driveL() {
	if (abs(vexRT[Ch3]) + abs(vexRT[Ch1]) > 20) //Controller dead-zone
		return (vexRT[Ch3] * ds - (vexRT[Ch1]));
	return 0;
}

float driveR() {
	if (abs(vexRT[Ch3]) + abs(vexRT[Ch1]) > 20) //Controller dead-zone
		return (vexRT[Ch3] * ds + (vexRT[Ch1]));
	return 0;
}

//Flywheel control task -basic
//TODO implement PID
task flywheelControl() {
	bool flywheelOn = false;
	while (true) {
		if (flywheelOn) {
			motor[FLY_W_A] = fs;
			motor[FLY_W_B] = fs;
		}
		else {
			motor[FLY_W_A] = 0;
			motor[FLY_W_B] = 0;
		}
		if (vexRT[Btn5U]) {
			while (vexRT[Btn5U]) {}
			flywheelOn = !flywheelOn;
			if (flywheelOn == false) {
				for (int i = 0; i < fs / 2; i++) {
					motor[FLY_W_A] = fs / 2 - i;
					motor[FLY_W_B] = fs / 2 - i;
					wait1Msec(100);
				}
			}
		}
		if (vexRT[Btn8D]) {
			while (vexRT[Btn8D]) {}
			ds *= -1;
		}
		wait1Msec(20);
	}
}

task main() {
	startTask(flywheelControl); //Start flywheel control task
	//Driver control loop
	while (true) {
		motor[INTAKE] = (vexRT[Btn6U] * -fs) + (vexRT[Btn6D] * fs); //Intake button control

		motor[L_DRIVE] = driveL(); //Set left drive
		motor[R_DRIVE] = driveR(); //Set right drive

		motor[ARM_L] = (vexRT[Btn7U] * -fs) + (vexRT[Btn7D] * fs); //Arm button control left
		motor[ARM_R] = (vexRT[Btn7U] * -fs) + (vexRT[Btn7D] * fs); //Arm button control right

		motor[FLIP] = (vexRT[Btn7L] * -fs / 4) + (vexRT[Btn7R] * fs / 4); //Flipper button control
		wait1Msec(20);
	}
}
